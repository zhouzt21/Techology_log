---
title: 指令集
date: 2023.04.10
tags: 系统知识整理
---

# ISA

### 0. 基本概念

- RISC（精简指令集）CISC（复杂指令集）都是图灵完备的

- RISC每条指令只需要一个时钟周期执行（执行时间和多周期命令大致相同），简化指令比复杂指令需要更少的晶体管硬件空间，为通用寄存器留下更多的空间。

- source target

### 1. 通用架构——三类汇编指令

运算指令的操作数只能来自寄存器/指令本身

#### 1.1 算术运算指令

- add/sub des ,src1,src2

- 加立即数：addi $s0, $s0, 1

- 逻辑按位运算： and    or   nor

- 逻辑移位运算：

  - sll (shift left logic)  srl (shift right logic)  

  - 最后一个操作数是移位量(shift amount)

#### 1.2 数据传送

- lw取字
  - 通过偏移量和基址来查找：lw $s0, 20($s1)     才表示a[5]（对于a[0]偏移5个字，20个字节）
  - 一个字是四个字节，4B=32b=1字
- 直接把数从$t0,保存到存放在$s1中，使用addi $s1, $t0, 0（move伪指令，move $s1, $t0； li取立即数伪指令 li $s2, 10)
- sw存字，伪指令move 
- 装载32位立即数到寄存器

  - 原因：addi中的立即数只能占用32位指令的一部分，会造成浪费。
  - 取高位立即数 lui ，把数的高位放在寄存器高位，并且将低十六位置0(lui s2, 4258)；低位再直接用或运算放进去（ori $s2, 7FFF；这里不能改成addi因为如果最高位为1会被认为是负数)
    - 注意这里要转化为十六进制再去高位低位，再转回十进制写成指令
      

#### 1.3 决策指令

- 相等则分支(branch if equal) beq $s0, $s1, label

- 不相等则分支 bne

  - ```assembly
    bne .., .., Else
    ... .., .., ..
    j Exit
    Else: ... .., .., ..
    Exit: ...
    ```

- 小于则置位 slt des src1, src2
- 无条件跳转 j Label

分支伪指令 blt bgt blr bge, move

### 2. MIPS指令集架构

#### 2.1 寄存器

- 8个临时寄存器、8个保存寄存器

* 低读取延时和高带宽
* 32个32位通用寄存器（$0~$31)
  * 整理每一位的作用（图）
* rs r
* PC（program counter）寄存器：用于存储当前正要执行的指令地址（PC<-PC+4)

存储器：读写最大的范围，0~（2^32-1）Byte

#### 2.2 MIP指令格式(机器语言)

MIPS指令集重要特征是均被编码为32bit的二进制编码（一条指令占4Byte)，并分为三种格式。

##### 2.2.1 I型 （立即数）

后三个字段拼接成16位的立即数字段

6+5+5+16

op rs rt constant/address

addi 的操作码是8

lw, sw的指令操作码分别为35 43（注意在写lw sw的时候，汇编语言和机器语言是交叉的）

##### 2.2.2 J型

6+5+5+16

Jump:

![image-20230410101055905](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230410101055905.png)

直接重新计算PC

- 跳转并链接（由调用者使用）

  - 无条件跳转
  - 将下一条指令的地址放入返回地址寄存器$ra中
  -  jal Label 

- 寄存器跳转 jump reg

  - 基本只和返回地址寄存器搭配

  - jr $ra
  - 由被调用者使用（过程结束之后）

##### 2.2.3 R型（Register type)

含有三个寄存器的运算指令

6+5+5+5+5+6

opcode（操作码） rs rt rd（目的操作数） shamt（移位量） funct（功能码）

add sub操作码都是0，但是功能码是32 34

逻辑移位码是R型

**图示**

![image-20230410102248408](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230410102248408.png)

### 3. 寻址方式辨析

#### 3.1 寄存器寻址

操作数来源和目标的寻址根据指令中编码从寄存器中读取操作数，并写回寄存器。

包括R型指令，I型指令

#### 3.2 立即数寻址

根据指令中的操作数进行寻址。一般是I型指令。

#### 3.3基址或偏移寻址

根据寄存器存储数组作为基地址，在存储器中进行偏移量寻址。

I型中的sw lw指令常用。

#### 3.4 PC相对寻址

根据两个源寄存器判断结果跳转到当前PC附近指令。

#### 3.5 伪直接寻址

J型指令 拼接

PC = { PC[31.. 28], target address, 00}

[【CO008】第二章 指令：计算机的语言（四） 计算机组成原理/计算机组成与设计_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1D14y1W7gd/?spm_id_from=333.788&vd_source=d2b02eb855b9a6f24687d064ffbf9139)

### 4.过程控制

- 主程序（调用者）将参数放在过程（被调用者）
  - 4个参数寄存器￥a0~$a3
- 

保存寄存器？

[【CO007】第二章 指令:计算机的语言（三） 计算机组成原理/计算机组成与设计_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1vP41157ZN/?spm_id_from=pageDriver&vd_source=d2b02eb855b9a6f24687d064ffbf9139)

