---
title: 处理器
date: 2023.05.10
tags: 系统知识整理
---

本节笔记与之前笔记的逻辑关系：

- “ISA”是从逻辑层面弄清楚我们需要实现功能的元操作，同时设置较好的指令格式来达到精简指令的目的；（指令最好分为 I R J类型来理解记忆）
- “汇编”一节的笔记，从实战体验了解逻辑层面对精简指令的使用如何能实现高层功能，比如形成更高一层的高级语言C语言（指令最好分为不同功能分类来记忆）；
- 这一节则是反过来深入硬件层面，了解如何安排指令的执行，了解指令对应的硬件中的数据通路。（要回到I R J分类来理解）

# 单周期处理器

### 1. 处理器基本概念

#### 处理器基本操作阶段

一条MIPS指令的执行分为5个阶段（指令周期）

- IF取指令
  - IF被所有指令公用
  - 主要功能是从指定地址获取指令数据，并自行预测下一次读取指令的地址。有可能会预测错误，所以会产生一定的代价，IFU的设计目标之一是减少预测的准确率，并同时降低错误预测代价。
  - valid-ready握手机制？？

- ID译码和读寄存器
- EX运算
- MEM访存与寄存
- WB写回

图示：

![image-20230424214147841](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230424214147841.png)

CPU执行时间

![image-20230424214106933](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230424214106933.png)

MPIS只是CPU design的一种（模块设计是简单的）

### 2. 功能模块设计——硬件模块单元

#### 2.1 ALU 运算单元

- 操作数最多为2，输入输出位宽均为32位

  - CarryIn为进位输入来自其他ALU（级联）
  - Binvert信号决定b输入是否取反再进行运算
  - CarryOut为进位输出，用于与其他ALU级联
  - Result为一位输出
  - Operation为控制信号，决定具体运算类型
  - ![image-20230424215210641](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230424215210641.png)
  - 上图可以实现与 或 加法/减法

- 指令

  - add/sub 整数的四则运算（ALU，基本都用来实现加减运算）
    - 加减法
      - 溢出
      - 32位ALU行波进位，直接级联；LSB的CarryIn输入为0，其他的CarryIn输入来自地位的CarryOut
      - 实现减法则对Binvert取1，取补码
      - 超前进位：为了支持beq, slt
    - 乘除
      - 中间
  - and/or

  - slt (set on less than) 小于则置位：a-b<0则置为1，即a-b的符号位
    - 如果没有溢出，输出就是符号位MSB；有溢出则符号位取反
      - overflow XOR Set （没有溢出且需要置位才置位）

  - beq（branch if equal) 相等则分支
    - ALU新添加一个输出zero

    - 两个数减法结果为0；所有结果或再求非


  - overflow detection溢出检测
    - MSB的CarryIn和CarryOut两者不相等（过异或门为1），则溢出

  - LSB/MSB specific processing 特殊处理
    - 大小端编址：高位在低地址，为大端编址（和我们习惯相近的）
    - MSB要溢出检测；LSB的Less输入来自MSB的less
    

#### 2.2 存储单元

##### 2.2.1 register 寄存器

- 两个独立的读入端口
- 一个写入端口和写入使能

##### 2.2.2 RF(Register file)寄存器堆

- 寄存器堆总是会输出两个寄存器值，但是有些指令（如 LW）可能只用到其中一个。
- 读取写入的寄存器编号，寄存器堆使能信号都是控制信号。控制信号是在指令译码阶段完成，指令译码器（Decoder）根据指令生成要读取或者要写入的寄存器编号，并且根据指令类型产生写入使能信号。

##### 2.2.3 lw/sw(Load/store word operation) 读取/写入操作

lw 指令需要读一个寄存器，写入一个寄存器；R 型指令如 add，需要读两个
寄存器，写一个寄存器。

- lw读取是一个组合逻辑；两个读端口需要输入要读取的寄存器编号，输出对应寄存器存储的值。
- sw写入是时序逻辑，写操作发生在时钟沿；一个写端口需要输入要写入的寄存器编号（5bit 宽），并且输入要写入的寄存器数据（32bit 宽）。添加写使能信号（RegWrite），只有当写使能信号有效时，在时钟沿才会执行寄存器堆写入操作。

##### 2.2.4 存储器

- 数据存储器的使用特性，每条指令或者不会到主存进行操作（如 add），或者读取一个地址中的数据（如 LW），或者对一个地址存储的数据进行修改（如SW）
- 同一个时钟周期，处理器最多只会访问主存的一个地址（该地址可能是读，可能是写）。所以主存**只有一个地址端口**，读和写的地址都复用该端口。
- **两个控制信号，MemRead 和 emWrite**，用于区分在一个时钟周期内，处理器是读主存还是写主存。
- 主存还有**两个数据端口**，一个用于写数据操作过程中要写入的值，一个用于读数据操作过程中输出已经存储的值。

<img src="C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230425001601068.png" alt="image-20230425001601068" style="zoom:50%;" />

#### 2.3 Immediate operation 立即数扩展单元

立即数拓展分为符
号拓展（sign-extend）、零拓展（zero-extend）和分支拓展（Branch-extend），分
别完成有符号数拓展，无符号数拓展，分支指令拓展，由 ExtOp 信号确定立即数
拓展单元的具体拓展方式。



16位扩充为32位的方法：反复复制MSB位(但要注意是否有符号，决定如何扩充位数)



通过一个多路选择器，和相应的控制信号 ALUSrc，我们可以
选择 ALU 输入的第二个操作数是来自于寄存器堆的第二个读数据端口的输出还
是来自于立即数拓展单元。经过 ALUSrc 信号选择过后的 ALU 操作数，和寄存
器堆第一个读端口的输出，共同输入算术逻辑单元（ALU），ALU 根据相应的
配置对两个操作数进行相应的算术和逻辑的计算。



### 3. 基础计算指令的数据通路实现

要注意指令操作需要的读入端口数量。

#### 3.1 I型计算指令

![image-20230425002421565](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230425002421565.png)

- 让**写回寄存器的阶段既能够支持写回主存数据，又能够直接写回 ALU计算结果**，增加一个多路选择器，。该多路选择 器的控制信号为**MemtoReg**。MemtoReg 为 1，代表将主存数据写回寄存器堆，MemtoReg 为 0，代表直接写回 ALU 的计算结果。
- 控制单元需要根据 I 型指令的类型，产生 ALU 的控制信号，指定 ALU 进行的具体操作（加、减、与、或等）。因为计算的 I 型指令既有算术运算，又有逻辑操作，所以控制模块还需要根据指令具体类型指定立即数拓展模块的拓展方式。比如，ADDI 指令要求以有符号数进行算术拓展，ANDI 指令要求以无符号数进行逻辑拓展。

<img src="C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230425003440339.png" alt="image-20230425003440339" style="zoom:67%;" />

#### 3.2 R型计算指令

- add与 addi 的区别仅在于 ALU 的第二个操作数不同。仅需要控制单元
  控制图 VI-16 中的 ALUSrc 信号，选择输入为 op2 即可。
  因为立即数拓展的结果不会用于后续运算，所以 R 型指令中立即数拓展模块
  的功能选择是零拓展还是有符号数拓展对最终结果没有影响，这里用 X 表示，
  对最终结果没有影响（Do not care）。

<img src="C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230425003508329.png" alt="image-20230425003508329" style="zoom:67%;" />

- 我们从访问代价的角度考虑，让 MemRead 信号只有在确定需要读取内存的时候才有效，其他情况均保持无效。

#### 3.3 分支指令（I型）

分支功能的数据通路主要增加了

-  1）分支拓展单元
  - 将输入的立即数翻译成为指令寄存器中地址的偏移量。即*4的移位器（有符号）
- 2）分支目标地址计算
  - 分支目标地址计算是通过一个加法器将该地址偏移转换成实际 PC 目标地址（PC+4+800）
- 3）PC 选择的多路控制器和控制信号

PCSrc 信号（PC Source，PC 寄存器源信号）来指示正在执行的指令是否是**分支指令**。仅 PCSrc 和 zero 信号都为高（既是分支指令，同时跳转判断跳转条件也满足）时，PC 才会跳转到分支目标地址。

#### 3.4 跳转指令

##### jal跳转并链接（J型指令）

转的指令的基础上，将程序运行状态（PC）寄存器的值保存到 $ra 寄存器
中，往往用于过程调用结束之后用来恢复程序运行状态。

J型指令不访问寄存器堆，也不进行逻辑计算、内存访问，仅修改PC寄存器的值。

PC 1）顺序执行地址，2）分支地址， 3）跳转指令地址（JumpAddr）

- 故而用一个三选一多路选择器来最终确定 PC 目标地址。3 选 1 选择器需要两个控制信号，
  增加一个 PCSrc2 信号，用来指示当前指令是否是**跳转（Jump）指令**。
- J 型指令有 6bit 操作码和 26bit 跳转地址(Jaddress)。我们还需要一个跳转地址拓展单元将 26bit 跳转地址(Jaddress)组装成 PC 寄存器能够直接取指令的 32bit指令寄存器地址（JumpAddr）。
-  J型指令的跳转采用伪直接寻址方式完成，即，高 4 个 bit 直接采用 PC+4 的
  对应位置的数据，低 2bit 用 0 填充。这是因为所有指令在内存中都是 4 字节对齐
  的，因此最低的 2 个比特位是无需存储。表达式为： JumpAddr = {PC+4[31:28],
  Jaddress, 2’b0}。

在单周期中，R[31]=PC+4，是将下一条指令的地址进行保存，当过程调用结束之后，直接从下一条指令开始运行；在流水线处理器中，当目前的指令（PC）解码完成，确定是一条 jal 指令之后，下一条指令（PC+4）已经进入了取值阶段，并会在后续操作中执行，这就是所谓的“延迟槽”，所以流水线处理器jal 指令在$ra 保存的是紧接着的尚未执行的指令（PC+8），即流水线处理器，jal表达式为 $ra = PC+8; PC = JumpAddr。关于“延迟槽”，会在之后流水线部分进行说明。此处只需要理解，jal 指令保存的 PC 地址在单周期和流水线中是不同的。

##### jr 跳转到寄存器（R型指令）

Jump 指令跳转到伪直接寻址之后的目标地址，jr 指令跳转到寄存器存储的数据代表的地址。我们增加一个 2 选 1 多路选择器和对应的控制信号（JumpSrc）来选择跳转指令的目标是伪直接寻址还是寄存器值。当 JumpSrc 为 0 时，代表伪直接寻址，当 JumpSrc 为 1 时，代表跳转到寄存器的值。



### 4. 控制信号分析和逻辑设计

![image-20230425004838245](C:\Users\zhouzhiting\AppData\Roaming\Typora\typora-user-images\image-20230425004838245.png)

MemtoReg







## 多周期处理器























