---
title: Verilog
date: 2023-03-26 
tags: 系统整理
---

# Verilog学习笔记

## 1.基本概念

#### 1.1设计流程：

设计--电路综合（逻辑、综合、布线）--仿真验证（设计、功能、时序）--硬件实现

#### 1.2 描述级别（详细见 3.模块化编程）

门级--RTL级--行为级

#### 1.3 设计方法

top-down方法（自顶向下）

定义顶层模块功能，再分析构成顶层模块的必要子模块



## 2.语法

### 2.1 数据类型

#### Wire

硬件单元之间的物理连线，由其连接的器件输出端**连续驱动**。没有驱动元件连接到 wire 型变量，缺省值一般为 "Z"。

~~~verilog
wire   interrupt ;
wire   flag1, flag2 ;
wire   gnd = 1'b0 ;
~~~

#### Reg

用来表示存储单元，它会保持数据原有的值，直到被改写。寄存器不需要驱动源，也不一定需要时钟信号。

* 综合：在 always 块中可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。

* 赋值：可在任意时刻通过赋值操作进行改写。

* Reg型变量需要被明确地赋值，在设计中变量必须放在过程块语句中（如initial或always），通过过程赋值语句赋值，而且在过程块内被赋值的每一个变量必须定义成该类型


#### 向量

位宽大于 1 时，wire 或 reg 即可声明为向量的形式。

* 注意声明的时候大位在前，到0 结束

* 可以“切片”，指定一部分作为其他逻辑使用；也支持变量域选择

* 可以有向量数组 （变量类型名后跟的是位数，实例名后面跟的是数组对应维度大小）

  注意向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1。它们在结构的定义上有所区别。

  ~~~verilog
  reg [31:0]     data1 ;
  reg [7:0]      byte1 [3:0]; //4个8位寄存器
  integer j ;  //注意整数类型是interger
  always@* begin
      for (j=0; j<=3;j=j+1) begin
          byte1[j] = data1[(j+1)*8-1 : j*8];  
          //切片（连续访问可以 data1[31-: 8]; 相当于 data1[31:24] ;)
          //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]
      end
  end
  
  //reg [31:0]   data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组
  ~~~

* 可以重新组合，要用大括号（多个相同片段直接在大括号前写次数）

  ~~~verilog
  wire [31:0]    temp1, temp2 ;
  assign temp1 = {byte1[0][7:0], data1[31:8]};  //数据拼接
  assign temp2 = {32{1'b0}};  //赋值32位的数值0  
  ~~~

### 数值数据类型

#### integer

声明时不用指明位宽，位宽和编译器有关，一般为32 bit（作用是辅助生成硬件电路，实际电路中没有这个信号）。reg 型变量为无符号数，而 integer 型变量为有符号数。

#### real

可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。

#### parameter

用来表述常量，只能赋值一次。

#### 字符串

保存在reg类型变量中，每个字符占用一个字节（注意寄存器宽度，不要溢出）。

~~~verilog
reg [0: 14*8-1]       str ;
initial begin
    str = "run.runoob.com";
end  
~~~

#### 数值转换

后续展开



### 2.2表达式

表达式可以在出现数值的任何地方用。

#### 操作数

操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。

#### 操作符

**等价操作符**

包括逻辑相等（==），逻辑不等（!=），全等（===），非全等（!==）。逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。

~~~verilog
A = 4 ;
B = 8'h04 ;
C = 4'bxxxx ;
D = 4'hx ;
A == B        //为真
A == (B + 1)  //为假
A == C        //为X，不确定
A === C       //为假，返回值为0
C === D       //为真，返回值为1
~~~

**逻辑操作符**

逻辑操作符主要有 3 个：&&（逻辑与）, ||（逻辑或），!（逻辑非）。

**按位操作符**

包括：取反（~），与（&），或（|），异或（^），同或（~^）。对 2 个操作数的每 1bit 数据进行按位操作。（注意^是异或，不是乘方）

**归约操作符**

包括：归约与（&），归约与非（~&），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。

**移位操作符**

移位操作符包括左移（<<），右移（>>），算术左移（<<<），算术右移（>>>）。



**条件表达式**

~~~ verilog
assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 :
                (addr[9:8] == 2'b01) ? hsel_p2 :
                (addr[9:8] == 2'b10) ? hsel_p3 :
                (addr[9:8] == 2'b11) ? hsel_p4 ;
~~~



### 2.3 过程控制 

#### 2.3.1 initial和always

initial与always不能嵌套使用。一个module可以有多个。是并行执行的。

* 语句内部是顺序执行的。（除非阻塞语句）
* 每个语句都会产生独立的控制流，执行时间从0开始。

**initial**

* 从 0 时刻开始执行，只执行一次。（没有敏感表达式）
* 不可综合的，多用于初始化、信号检测等。
* 不可被综合，因为没有只执行一次的电路（特殊情况：我们现在使用的FPGA有一次上电之后的配置；其他的不一定，ASIC肯定不行）

**always**

* 是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。
* 由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。

#### 2.3.2 顺序、并行

* 顺序块用关键字 begin 和 end 来表示。每条语句的时延总是与**其前面语句执行的时间**相关。
* 并行块有关键字 fork 和 join 来表示。语句是并行执行的，即便是阻塞形式的赋值。时延都是与**块语句开始执行的时间**相关。
  * 需要使用阻塞性赋值保证执行关系

* 命名块之间的访问和禁用（包括嵌套）； break 只能退出当前所在循环 ，而 disable 可以禁用设计中任何一个命名的块。

~~~verilog
//妙哉，仔细体会verilog的并行编程思想
module test;
 
    initial begin: runoob_d //命名模块名字为runoob_d
        integer    i_d ;
        i_d = 0 ;
        while(i_d<=100) begin: runoob_d2
            # 10 ;
            if (i_d >= 50) begin       //累加5次停止累加
                disable runoob_d3.clk_gen ;//stop 外部block: clk_gen
                disable runoob_d2 ;       //stop 当前block: runoob_d2
            end
            i_d = i_d + 10 ;
        end
    end
 
    reg clk ;
    initial begin: runoob_d3
        while (1) begin: clk_gen  //时钟产生模块
            clk=1 ;      #10 ;
            clk=0 ;      #10 ;
        end
    end
 
endmodule
~~~

- Verilog中语句执行顺序的理解. verilog主要的模块之间都是并行执行的。例如各个always之间 如果你在一个always中要对a赋值，而在另一个always中要使用a的值，这时候就要注意了，两者并行的，处理先后不能确定。而在always内部，一般使用了begin…end。. 这里面的内容都是顺序执行的。比如b=a； c=b，先执行一条，再执行下一条，那就是c=a了 如果里面有两组if/else，就是先执行前一组，再执行后一组。

### 2.4 时序控制

**时延控制**

常规时延：#n 语句; (或者直接单独写成一个时延执行语句)

内嵌时延：先将计算结果保存，然后等待一定的时间后赋值给目标信号。内嵌时延控制加在赋值号之后。

* 当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。

  当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。

**边沿触发控制**

* 一般事件：事件控制用符号 **@** 表示。关键字 posedge 指信号发生边沿正向跳变，negedge 指信号发生负向边沿跳变，未指明跳变方向时，则 2 种情况的边沿变化都会触发相关事件

  * 敏感列表（or 或者 , 连接）；太繁琐的时候直接使用**@\*** 或 **@(\*)**

* 命名事件：event（事件）类型的变量，并触发该变量来识别该事件是否发生。命名事件用关键字 event 来声明，触发信号用 **->** 表示。

  * ~~~verilog
    event     start_receiving ;
    always @( posedge clk_samp) begin
        -> start_receiving ;       //采样时钟上升沿作为时间触发时刻(成为命名事件)
    end
     
    always @(start_receiving) begin
        data_buf = {data_if[0], data_if[1]} ; //触发时刻，对多维数据整合
    end
    ~~~

**电平敏感控制**

上述是要等待信号变化或事件触发，用 **@+敏感列表** 的方式来表示；也可以直接用电平，用关键字 wait 来表示这种电平敏感情况。

~~~verilog
wait (start_enable) ;      //等待 start 信号
~~~



### 2.5赋值

#### 2.5.1 连续赋值

**第一类连续赋值——assign deassign**

```
assign     LHS_target = RHS_expression  ；
```

LHS_target必须是一个标量或者线型向量，不能是寄存器类型；RHS_expression没有要求，可以是标量或线型或存器向量，也可以是函数调用，只要 RHS_expression 有变化就会重新计算赋值给LHS_target。

也可以声明的时候同时赋值。wire的赋值只能有一次，连续赋值的方式也只能有一次。

一位全加器：

~~~verilog
module full_adder1(
    input    Ai, Bi, Ci
    output   So, Co);
 
    assign {Co, So} = Ai + Bi + Ci ;
endmodule
~~~

**第二类连续赋值——force relese（强制赋值）**

后续展开

**时延**

* 时延一般是不可综合的。
* 连续赋值时延一般可分为普通赋值时延、隐式时延、声明时延。

~~~verilog
//普通时延，A&B计算结果延时10个时间单位赋值给Z
wire Z, A, B ;
assign #10    Z = A & B ;
//隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。
wire A, B;
wire #10        Z = A & B;
//声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。
wire A, B;
wire #10 Z ;
assign           Z =A & B

    //上述这些：如果在这 10 个时间单位内，即在 Z 获取新的值之前，A 或 B 任意一个值又发生了变化，那么计算 Z 的新值时会取 A 或 B 当前的新值。（而实际会有惯性时延)
~~~

* 惯性时延：当输入较小宽度的脉冲将会被滤除，即不允许所有宽度小于指定延迟的脉冲通过电路单元，那么能够让对应输出有变化的最小脉冲宽度即为惯性延迟，是所有的电子器件均存在的一种延迟特性；在仿真过程中，该延迟用于模拟元件延迟。一般原语、门单元、开关单元、连续赋值等中的延迟在模拟时均为惯性延迟。

#### 2.5.2 过程赋值

在always、initial里赋值，赋值对象是寄存器、整数、实数。连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果；过程赋值只有在语句执行的时候，才会起作用。

**阻塞赋值**(=)

阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。

**非阻塞赋值**（<=)

非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。

注意：

* 切记不要在一个过程结构中混合使用阻塞赋值与非阻塞赋值。两种赋值方式混用时，时序不容易控制，很容易得到意外的结果。

  更多时候，在设计电路时，always 时序逻辑块中多用非阻塞赋值（避免竞争），always 组合逻辑块中多用阻塞赋值；在仿真电路时，initial 块中一般多用阻塞赋值。



### 2.6 常用语句

#### 2.6.1循环语句

只能在always initial块中使用

**while**

* 疑问，condition的判断，是整个语句块执行之后进行，还是一直在判断？

**for**

* 注意不能像C一样，简写为i++
* 

**repeat**

* repeat 循环的次数必须是一个常量、变量或信号。

#### 2.6.2 多路分支语句

**case**

```verilog
case(case_expr)
    condition1     :             true_statement1 ;
    condition2     :             true_statement2 ;
    ……
    default        :             default_statement ;
endcase
```

- 条件选项可以有多个，不仅限于 condition1、condition2 等，而且这些条件选项不要求互斥。
- 虽然这些条件选项是并发比较的，但执行效果是**谁在前且条件为真谁被执行**
- case 语句中的 x 或 z 的比较逻辑是不可综合的，所以一般不建议在 case 语句中使用 x 或 z 作为比较值。

#### 2.6.3 条件语句

**if-else**

```verilog
if (condition1)       true_statement1 ;
else if (condition2)        true_statement2 ;
else if (condition3)        true_statement3 ;
else                      default_statement ;
```





## 3.模块化编程

结构建模方式有 3 类描述语句： Gate（门级）例化语句，UDP (用户定义原语)例化语句和 module (模块) 例化语句（使用最多）。

### 3.1 模块

![img](https://www.runoob.com/wp-content/uploads/2020/09/jxRkciGWpiEbvz3D.png)

上述5部分出现位置任意，但是变量在使用之前应该声明。

* **端口**：端口是模块与外界交互的接口。对于外部环境来说，模块内部是不可见的，对模块的调用只能通过端口连接进行—— 一般将不带类型、不带位宽的信号变量罗列在模块声明里。一个模块如果和外部环境没有交互，则可以不用声明端口列表。
  
  * 端口类型有 3 种： 输入（input），输出（output）和双向端口（inout）
    * input、inout 类型不能声明为 reg 数据类型，因为 reg 类型是用于保存数值的，而输入端口只能反映与其相连的外部信号的变化，不能保存这些信号的值。
    * output 可以声明为 wire 或 reg 数据类型。
    * 端口隐式的声明为 wire 型变量；
    * 可以在module声明的时候就陈列端口和类型（简洁）
  
* **模块例化**：在一个模块中引用另一个模块，对其端口进行相关连接，叫做模块例化。模块例化建立了描述的层次，信号端口可以通过位置或名称关联。

  * 命名端口例化
    * 将需要例化的模块端口与外部信号按照其名字进行连接，端口顺序随意，可以与引用 module 的声明端口顺序不一致，只要保证端口名字与外部信号匹配即可。	

  * 顺序端口连接：按顺序匹配，位置要一致，才省。（可读性不高）
  * 端口连接：
    * 例化时，从模块外部来讲， input 端口可以**连接 wire 或 reg 型变量**。这与模块声明是不同的，从模块内部来讲，input 端口**必须是 wire **型变量。
    * 例化时，从模块外部来讲，output 端口必须**连接 wire 型变量**。这与模块声明是不同的，从模块内部来讲，output 端口**可以是 wire 或 reg 型变量**。
    * 例化时，从模块外部来讲，inout 端口必须连接 wire 型变量。这与模块声明是相同的。
    * 悬空：后续展开

  * generate例化

    * generate 语句进行多个模块的重复例化，可大大简化程序的编写过程。

      * ~~~verilog
        `timescale 1ns/1ns
         
        module test ;
            reg  [3:0]   a ;
            reg  [3:0]   b ;
            //reg          c ;
            wire [3:0]   so ;
            wire         co ;
         
            //简单驱动
            initial begin
                a = 4'd5 ;
                b = 4'd2 ;
                #10 ;
                a = 4'd10 ;
                b = 4'd8 ;
            end
         
            full_adder4  u_adder4(
                       .a      (a),
                       .b      (b),
                       .c      (1'b0),   //端口可以连接常量
                       .so     (so),
                       .co     (co));
         
            initial begin
                forever begin
                    #100;
                    if ($time >= 1000)  $finish ;
                end
            end
         
        endmodule 
        ~~~

  * 带参数的模块例化：后续展开

* 自顶向下的模块

  * ![img](https://www.runoob.com/wp-content/uploads/2020/09/4EEC5MktHZA7Y0sq.png)

  * 通过 . 来访问不同层次

    * ~~~verilog
      //u_n1模块中访问u_n3模块信号:
      a = top.u_m2.u_n3.c ;
      ~~~



### 3.2 函数与任务

利用任务（关键字为 task）或函数（关键字为 function），将重复性的行为级设计进行提取，并在多个地方调用，来避免重复代码的多次编写，使代码更加的简洁、易懂。

#### 3.2.1函数

函数只能在模块中定义，位置任意，并在模块的任何地方引用，作用范围也局限于此模块。

* 不含有任何延迟、时序或时序控制逻辑
* 至少有一个输入变量
* 只有一个返回值，且没有输出
* 不含有非阻塞赋值语句
* 可以调用其他函数，但是不能调用任务

~~~verilog
function [range-1:0]     function_id ;
input_declaration ;
 other_declaration ;
procedural_statement ;
endfunction
~~~

**常数函数**

常数函数是指在仿真开始之前，在编译期间就计算出结果为常数的函数。常数函数不允许访问全局变量或者调用系统函数，但是可以调用另一个常数函数。

**automatic函数**

Verilog 一般函数的局部变量是静态的，即函数的每次调用，函数的局部变量都会使用**同一个存储空间**。若某个函数在两个不同的地方同时并发的调用，那么两个函数调用行为同时对同一块地址进行操作，会导致不确定的函数结果。

Verilog 用关键字 automatic 来对函数进行说明，此类函数在调用时是可以**自动分配新的内存空间**的，也可以理解为是**可递归的**。因此，automatic 函数中声明的局部变量不能通过层次命名进行访问，但是 automatic 函数本身可以通过层次名进行调用。

- 不太懂，后续展开

#### 3.2.2 任务

任务（task）可以用来描述共同的代码段，并在模块内任意位置被调用，让代码更加的直观易读。函数一般用于组合逻辑的各种转换和计算，而任务更像一个过程，不仅能完成函数的功能，还可以包含时序控制逻辑。

- 任务可以没有或者有多个输入，且端口声明可以为 inout 型
- 任务可以没有或者有多个输出
- 任务没有返回值
-  任务可以在非零时刻执行
- 任务不能出现 always 语句，但可以包含其他时序控制，如延时语句
- 任务可以调用函数和任务
- 任务可以作为一条单独的语句出现语句块中

~~~verilog
task       task_id ;
    port_declaration ;
    procedural_statement ;
endtask
~~~

任务的逻辑设计时，可以把 input 声明的端口变量看做 wire 型，把 output 声明的端口变量看做 reg 型。避免时序错乱，建议 output 信号采用阻塞赋值。

**调用**

* 任务可单独作为一条语句出现在 initial 或 always 块中，格式与函数类似。调用时，端口必须按顺序对应。
* 输入端连接的模块内信号可以是 wire 型，也可以是 reg 型。
* 输出端连接的模块内信号要求一定是 reg 型，这点需要注意。

**任务操作全局变量**

任务内部变量也只有在任务中可见，如果想具体观察任务中对变量的操作过程，需要将观察的变量声明在模块之内、任务之外，可谓之"全局变量"。

后续展开

**automatic任务**

后续展开





编译向导是一类特殊的Verilog HDL语句，他的目的是对Verilog HDL的编译过程实现控制。在程序中，编译向导以符号`标识



- `define：  `define A 100**;**

– 用于为一个复杂的名字和字符串定义一个简单的名字或标志符。在

引用这个标志符时，注意在前面加上`符号

- `timescale；`timescale 1ns**/**1ps

– 用于定义模块的时间单位与时间精度，调用方式`timescale <时间

单位>/<时间精度>

- 条件编译:`ifdef，`else， `endif

`ifdef 宏名 

​	一组描述语句

`else

另一组描述语句

`endif

- `resetall：取消前面所有编译向导引入的定义，并恢

  复其原始的缺省态







**$display("****格式控制字符串****"****，输出变量名表项****);**

**$write("****格式控制字符串****"****，输出变量名表项****)****；**



**$monitor("****格式控制字符串",输出变量名表项)***

$monitoron;

$monitoroff



**display****与****monitor****的区别**

**display****每调用一次，则执行一次；而**

**monitor****一旦被调用，则相当于启动了一**

**个后台进程，将随时对输出变量名表项列**

**出的各项进行监测，一旦发现其中任何一**

**个在某一时刻有变化，则输出一次变量结**

**果；而****monitoron****与****monitoroff****则是对后台**

**进程的开关管理**



系统函数$time与$realtime

– 调用形式：$time，$realtime，分别返回一个64位整数或实型数，

表示被调用的时刻的时间值

系统任务$finish和$stop

– $finish的作用为中止仿真器的运行，结束仿真过程

– $stop的作用为暂停仿真器的运行，此时设计人员可以输入相应的

命令，对模拟过程进行交互控制，然后接着运行

系统函数$random

– $random用于产生一个随机数，其调用方式为$random %b，他将产

生一个从(-b+1)到(b-1)之间的随机数

仿真的时候可以大胆取模









### 3.3状态机



### 3.4竞争和冒险



### 3.5锁存的避免





## 4. 进阶

### 不可综合

Verilog是硬件描述语言，进行逻辑综合是其中重要但不唯一的一个功能，另一部分重要的功能是进行仿真验证和时序分析等，这些部分不必实现成电路，可以使用不可综合的语法



验证和测试

验证

– 检查设计实现是否能够满足设计需求，发现设计错误的过程，是设计过程的反过程，验证发现的问题可以通过重新设计进行更正，在很多情况下，一个设计的70%以上的时间都被应用到验证上

- 仿真

前仿真：



根据不同的需要：

- 在系统级仿真时，主要验证系统的数学模型、算法结

构的行为是否正确，应尽可能采用抽象程度较高的语

句，以使程序简洁明了。此时，电路的各种延时都不

予考虑，所有的语句及数据类型均可使用

- 在RTL级仿真时，主要验证被测模块是否符合逻辑工具

  的要求，能否生成相应的正确的门级电路，此时测试

  平台程序设计应注意：不能使用浮点数；必要时需要

  考虑门延时，但连线延时可以不考虑



测试的基本原则：

模拟实际情况：

- 增加激励信号的随机性，比如可以随机调整数据包发

生器发出数据包的长度。

- 在激励信号中人工插入错误（可以是随机错误，也可

以是固定模式错误），检验被测设计能否识别错误并

正确处理情况

灵活编写测试矢量



查看仿真波形：

可以在scopes中看到各模块中的各信号

不关心的信号，如sysclk，可以在波形图中删掉再仿真，提高一些仿真速度

可在Tcl console 窗口输入命令restart, run 100ms 等





UUT（unit under test)



看一下文档





测试

– 检验芯片是否在生产和加工环节存在缺陷，这些缺陷往往是由于材料、工艺等因素造成的，不能依靠设计过程加以避免

比如不用异步电路（难分析也难测试）









#### 不可综合的常量

：x

参数性常量：parameter, localparam

##### Parameter



parameter定义标志符，可在外部改变；localparam 定义本地标志符，不可在外部改变



demo_para **#(.**p1**(**4**),.**p2**(**5**),.**p3**(**6**))** g1**(...);**



显式

demo_para g1(...);

defparam g1**.**p1**=**4**,**g1**.**p2**=**5**,**g1**.**p3**=**6;



整数型变量，实数型变量 不可综合

#### 不可综合的延时

延时也是不可被综合的

- 门级延时表示从**基本门的输入端发生变化到输出端发生变化**的门传输延时

- assign语句延时表达了赋值表达式右端的变化反映到左端连线上的**信号发生变化**的延时时间
- 连线延时直接体现了信号在连线上的传输延时
- 缺省延时为0，延时一般表示方法#(d1,d2,d3)，其中d1表示转移到1状态的延时，即上升沿延时；d2表示转移到0状态的延时，即下降沿延时；d3表示转移到z状态的延时，也称关断延时。d1、d2、d3地单位是由`timescale语句确定的
- 更复杂的情况：定义了最小值、典型值和最大值（：分隔），模拟器通过选择不同情况的延时值进行仿真，表示最好情况、典型情况和最差情况

#### 不可综合的语句

##### Initial



##### 循环语句

虽然可以做综合，但并不建议，只用来仿真；希望做综合是能清晰估计出需要使用的资源，而循环语句规避了底层的设计

for





## Vivado使用

### XDC文件

\# 外部时钟输入约束

create_clock -period (clock period) -name (clock name) -waveform {(Traise), (Tfall)} 

[get_ports (clock port name)]

\# 举例说明

create_clock -period 10.000 -name CLK -waveform {0.000 5.000} [get_ports sysclk]

\# 已建立的时钟改名

create_generated_clock -name (clock name) [get_pins (path)]

\# 建立时钟组

set_clock_groups -name (group name) -asynchronous -group {(clock name) (clock 

name)}

set_clock_groups -name (group name) -asynchronous -group [get_clocks (clock 

name)]



\# 管脚分配

set_property PACKAGE_PIN (pin location) [get_ports (port name)]

set_property IOSTANDARD (level: LVDS, LVCMOS18, LVCMOS33 etc.) 

[get_ports (port name)]

\# 举例说明

set_property PACKAGE_PIN T18 [get_ports rst]

set_property IOSTANDARD LVCMOS33 [get_ports rst]

\# 也可以将上面两行合并

set_property {PACKAGE_PIN T18 IOSTANDARD LVCMOS33} [get_ports rst]

\# 将非时钟**专用管脚**用作时钟线

set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets (port_name)]

---





## 5. 行为级仿真

### testbench

testbench就是对写的FPGA文件进行测试的文件，可以是verilog也可以是VHDL。verilog和VHDL的国际标准里面有很多不能被综合实现的语句，比如initial，forever，repeat，延时语句#1等等，这些语句就是用来测试的时候使用的。运行环境一般是ise或者vivado自带的仿真工具，或者如modelsim一样的第三方仿真工具。

#### 工作机制

任何一个设计好的模块（比如第一讲的PWM产生模块），都有输入和输出，此模块是否满足要求就是看给定满足要求的输入，是否能够得到满足要求的输出。所以testbench的测试机制就是**：用各种verilog或者VHDL语法，产生满足条件的激励信号（也就是对被模块的输入），同时对模块的输出进行捕捉，测试输出是否满足要求**。如下图，产生激励输出验证模块两个模块都属于testbench，最好的输出验证模块最终只需要给一个pass和fail的答案出来就可以了。不管是用一个信号表示pass和fail还是用$display()函数打印，最终简单明了的给出过或者不过的信息就好了。







----

### 关于点亮LED灯来理解时序控制

仍是使用高频率的系统时钟的高低电平控制，这个时候是用计数的方法，使得在计数没有达到预设参数时的边沿触发不会变（仍然保持不亮的状态），计数值到的那一个时钟边沿触发时，led才由不亮转亮（因为使用的是寄存器来控制灯，所以边沿触发是改变状态并保存下来）。

例如下面的代码（clk_divide换成led)：要预先设置好count的位数和大小

```verilog
always @(posedge clk or posedge reset)
begin
    if(reset) begin
        clk_divide <= 1'b0;
        count <= 32'd0;
    end
    else begin
       begin
          count <= (count==CNT-32'd1) ? 32'd0 : count + 32'd1;
          clk_divide <= (count==32'd0) ? ~clk_divide : clk_divide;
       end
    end
end
```

