---
title: 汇编
date: 2023.04.10
tags: 系统知识
---

# 汇编学习笔记

命令标识符:  .

## 1 数据类型

### 变量

- 存储在主存储器里（不是寄存器里）
- 汇编中要load/store才能操作存储器里，编写程序的时候让变量在寄存器的的时间越长越好

### 数组

.word

来给数组开辟空间：在编译时静态地开辟n*4 bytes（n个32-bit字）

用sw lw访问数组

## 2 程序结构

#### 数据段

• 以“.data”记号开头。包括常量数据和固定数组的声明。

```assembly
.data # 在标签 i 的位置分配 8 个字节的空间
i: .space 8 
la $t0, i  #将标签 i 所在位置的地址加载到 $t0 寄存器中
```

- .align x
  - 将下一个数据项对齐到特定的byte边界。如果要读取的数据是以2byte，4byte，8byte为单位的，需要对齐到对应的边界上。x取值0表示1byte，1表示2byte，2表示4byte，3表示8byte。

- .ascii, .asciiz
  - 表示字符串，其中asciiz会自动在最后补上null字符。
  - `.asciiz` 指令后面跟随一个字符串，字符串的每个字符都被视为一个 8 位二进制数的 ASCII 码。该字符串以空字符（ASCII 码为 0）结尾，以表示字符串的结束。例如，`.asciiz "MIPS"` 定义了一个字符串常量 "MIPS"，其中 'M' 的 ASCII 码为 77，'I' 的 ASCII 码为 73，'P' 的 ASCII 码为 80，'S' 的 ASCII 码为 83，以及一个空字符的 ASCII 码为 0。
  - 一旦定义了字符串常量，程序可以使用**字符数组**或**字符串指针**来访问它。字符数组可以使用 `la` （load address）指令将其地址加载到寄存器中。例如，`la $t0, my_string` 将定义中的“my_string”字符串的地址加载到寄存器 $t0 中。字符串指针可以直接包含字符串的地址，并以这种方式传递到其他函数中。(?)

- .byte, .half, .word 

  - 表示数组常量按1byte，2byte，4byte存储

  - 在 MIPS 汇编语言中，`.word` 是一种声明伪指令，用于指示汇编器为给定的标签或符号分配一个 32 位的字（4 个字节byte）空间，以存储一些数据。

    一个字是2个字节(byte)，一个字节是4个比特；故4个字是32比特，寄存器的地址的间隔是4（因为地址是以字为单位的）

    例如，下面的代码使用了 `.word` 伪指令来声明一个名为 `my_array` 的数组，并初始化了其中的三个元素：

    ```assembly
    .data
    my_array: .word 10, 20, 30    # 定义一个大小为 3 的整型数组
    
    .text
    main:
        # 读取数组中的元素并打印
        lw $t0, 0($s0)  # 读取第一个元素（亦可写作 "lw $t0, my_array"）
        li $v0, 1       # 执行系统调用 1：输出整型值
        move $a0, $t0   # 将要输出的数值放入 $a0
        syscall
    
        # 程序结束
        li $v0, 10      # 执行系统调用 10：退出程序
        syscall
    ```


- .space
  - 表示一个以byte计长度的数组。

#### 代码段

- 以“.text”记号开头。
  - 包括待执行的代码和行标记。

#### 注释

- “#”为注释标记。
  - 可以出现在任意位置。
  -  “#”及其之后的所有内容均被忽略。

## 3 指令集

### 3.0 指令与伪指令

* 指令：能直接翻译为机器码的
* 伪指令：还要翻译成指令才能执行（更简洁易懂）
  * 在 MIPs 汇编语言中，`.asciiz` 是一种伪指令，用于定义 ASCII 字符串常量。


下面深入理解和区分相关MIPS指令（按照功能）。

### 3.1 算术指令集

#### 3.1.1 关于符号扩展

- 符号扩展与零扩展

  - 对16位立即数imm，在执行加法指令之前都符号扩展成32位数（与符号扩展对应的是零扩展）。
  - 无符号扩展：直接将扩展后的数据的高(32-n)位置为0。
  - 符号扩展：将扩展后的数据的高(32-n)位置为立即数的最高位。

- add, addi, addiu, addu的区别

  - ![img](https://images2017.cnblogs.com/blog/292886/201709/292886-20170913092308578-1097918893.png)

  - **addi**是加立即数指令，**支持溢出检测**，具体表现为：遇到溢出时，溢出错误标志变为高电平，传送到控制器cu中，导致此时的寄存器**写使能信号regwr无效**，最终结果为不将运算结果写入目的寄存器。

  - **addiu**是加立即数指令，**不受溢出限制**，具体表现为：遇到溢出时，对溢出的结果进行32bit**求模**，将求模结果写入目的寄存器中，因而不受溢出限制。

    ADDI和ADDIU：

    1）仅支持**有符号运算**（补码运算），16位立即数需要进行符号扩展；认为第一位是符号位时，只需要使用补码取模就可以得到正确结果的补码。

    2）ADDI带有溢出检测（或者说带“自陷”功能，虽然不常用）。

  - **add**：是将rs与rt中的值相加，结果存储在rd寄存器中。检测溢出。如果不溢出，将结果存储在rd寄存器中，如果溢出，抛出溢出异常，不改变rd中的值。

  - **addu**是将rs与rt中的值相加，结果存储在rd寄存器中。不检测溢出，如果溢出，不会抛出异常。
    add是有符号数加法，addu是"无符号数"加法，但是对于cpu来说，都是一样的，不管有没有符号位，都是从最低位加，进位，一直到最高位。

  - **对于CPU来说，有符号或者无符号都不重要。他们的运算都是一样的，不管有没有符号位，都是从最低位加，进位，一直到最高位，区别在于是否具有溢出检测。**[(17条消息) 【MIPS汇编】ADDI，ADDIU，ADD，ADDU的区别、有符号无符号的谬误_寒泉Hq的博客-CSDN博客](https://blog.csdn.net/sinat_42483341/article/details/89511856)

- 关于装载立即数（16位 32位讨论）

  - 要讨论的原因：因为指令中立即数的长度只有16位，所以需要讨论是否有符号，以及计算中16位需要符号扩展；同时超过16位的立即数，本身需要拆分成三条指令来完成计算（因为或运算不管是不是符号位直接逻辑计算）
    - [(17条消息) MIPS中addi指令被分成三条指令的问题_addi 0xf_Insomnialoveffff的博客-CSDN博客](https://blog.csdn.net/weixin_38889219/article/details/119984580)
    - 当立即数在0x00000000~0x7fffffff范围内时，mars认为你想表示一个正的立即数。
      - 0x00000000~0x00007fff，imm字段能放下，一条指令实现。
      - 0x00007fff~0x7fffffff，imm字段放不下太大的正数，三条指令实现。
    - 当立即数在0x80000000~0xffffffff范围内时，mars认为你想表示一个负的立即数。
      - 0x80000000~0xffff7fff，imm字段放不下太小的负数，三条指令实现。
      - 0xffff8000~0xffffffff，imm字段能放下，一条指令实现。

#### 3.1.2 关于逻辑左/右移与算术左/右移

- 逻辑左移=算数左移，右边统一添0 

- 逻辑右移，左边统一添0 

- 算数右移，左边添加的数和符号有关

e.g:1010101010，其中[]是添加的位

逻辑左移一位：010101010[0]

算数左移一位：010101010[0]

逻辑右移一位：[0]101010101

算数右移一位：[1]101010101





### 3.2 数据传送

**li**

- 在MIPS汇编中，li是"load immediate"的缩写，其意义是将一个立即数加载到寄存器中。立即数指的是一个常量值，常用于在程序中进行临时存储和运算。li指令的语法：li $t0, immediate

- li指令只能用于将16位（或者更少）的立即数加载到寄存器中，如果需要加载更大的常量值，可以采用先加载高16位，再加载低16位的方法：

```assembly
lui $t0, high_16_bits
ori $t0, $t0, low_16_bits
```

- 其中，t0是一个目标寄存器，ℎ��ℎ16����和���16����是需要加载到寄存器中的常量值的高16位和低16位。执行完上述代码后，*t*0是一个目标寄存器，*hi**g**h*16*b**i**t**s*和*l**o**w*16*b**i**t**s*是需要加载到寄存器中的常量值的高16位和低16位。执行完上述代码后，t0寄存器中的值就是high_16_bits和low_16_bits拼接起来的32位常量值。

**lui**

- 在MIPS汇编中，lui是"Load Upper Immediate"的缩写，其意义是将一个立即数（immediate）的高16位加载到一个寄存器中，低16位补零，称为符号扩展（sign extension）。lui指令的用法如下：lui $t0, immediate

**la**

- 在MIPS汇编中，la是"load address"的缩写，其意义是把某个全局变量或者数据的地址装入寄存器中。当我们需要使用某个变量或数据时，我们需要先加载它的地址到寄存器中，然后使用load指令从该地址中读取数据。la指令的语法如下：la $t0, var_name
- 其中t0是一个目标寄存器，var_name是需要加载地址的全局变量或者数据的名字。执行*la*指令后，t0寄存器中存储的就是var_name变量或者数据的地址，接下来我们就可以使用load指令从该地址中读取数据。



### 3.3 决策指令

- 分支语句的**目标位置用绝对地址**写

用PC值的相对地址

对应beq的寻址方式：PC相对选址

好处：代码在加载到不同地址的时候都能工作，绝对地址不行

slt

beqz



### 3.4 跳转指令

在程序起始处保存ra的习惯能避免在程序中有yal指令修改ra跳不回去

## 4 过程调用

调用者保护 和 被调用者保护



函数调用

调用时，临时寄存器和参数寄存器入栈（保护后续仍需要使用的变量和参数）

设置参数寄存器$a0~$a3

使用jal挑战到被调函数B

从占中恢复临时寄存器与参数寄存器



被调过程B：

将返回地址、保存寄存器入栈

使用输入参数

将返回地址、保存寄存器出栈

jr $ra返回主调过程A

（入栈和出栈是成对的）

### 4.1 栈

#### 一.栈的整体作用

**(1)保存现场/上下文**

**(2)传递参数:汇编代码调用c函数时，需传递参数**

**(3)保存临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量。**

**二.为什么汇编代码调用c函数需要设置栈**

**之前看了很多关于uboot的分析，其中就有说要为C语言的运行，准备好栈。而自己在Uboot的start.S汇编代码中，关于系统初始化，也看到有栈指针初始化这个动作。但是，从来只是看到有人说系统初始化要初始化栈，即正确给栈指针sp赋值，但是却从来没有看到有人解释，为何要初始化栈。所以，接下来的内容，就是经过一定的探究，试图来解释一下，为何要初始化栈。
要明白这个问题，首先要了解栈的作用。关于栈的作用，要详细讲解的话，要很长的篇幅，所以此处只是做简略介绍。总的来说，栈的作用就是：保存现场/上下文，传递参数，保存临时变量**

1.保存现场/上下文
指CPU运行的时候，用到了一些寄存器，对于这些寄存器的值，如果你不保存而直接跳转到子函数中去执行，那么很可能就被其破坏了，因为其函数执行也要用到这些寄存器。因此，在函数调用之前，应该将这些寄存器等现场，暂时保持起来(入栈push)，等调用函数执行完毕返回后(出栈pop)，再恢复现场。这样CPU就可以正确的继续执行了。
保存寄存器的值，一般用的是push指令，将对应的某些寄存器的值，一个个放到栈中，把对应的值压入到栈里面，即所谓的压栈。然后待被调用的子函数执行完毕的时候，再调用pop，把栈中的一个个的值，赋值给对应的那些你刚开始压栈时用到的寄存器，把对应的值从栈中弹出去，即所谓的出栈。
其中保存的寄存器中，也包括lr的值（因为用bl指令进行跳转的话，那么之前的pc的值是存在lr中的），然后在子程序执行完毕的时候，再把栈中的lr的值pop出来，赋值给pc，这样就实现了子函数的正确的返回。

**2.传递参数
C语言进行函数调用的时候，常常会传递给被调用的函数一些参数，对于这些C语言级别的参数，被编译器翻译成汇编语言的时候，就要找个地方存放一下，并且让被调用的函数能够访问，否则就没发实现传递参数了。对于找个地方放一下，分两种情况。一种情况是，本身传递的参数不多于4个，就可以通过寄存器传送参数。因为在前面的保存现场的动作中，已经保存好了对应的寄存器的值，那么此时，这些寄存器就是空闲的，可以供我们使用的了，那就可以放参数。另一种情况是，参数多于4个时，寄存器不够用，就得用栈了。**





----

[(15条消息) MIPS汇编快速入门_千灵域的博客-CSDN博客](https://blog.csdn.net/u012837895/article/details/79855896)















